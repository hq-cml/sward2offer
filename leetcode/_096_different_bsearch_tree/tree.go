/*
 * 不同的二叉搜索树
 * 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的
 * 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
 *
 * 输入：n = 3 => 输出：5
 *  1     1       2      3     3
 *    3    2    1  3    2    1
 *  2       3          1      2
 *
 * 输入：n = 1 => 输出：1
 */
package _096_different_bsearch_tree

// 思路：动态规划！
// 假设有n个结点，G(i)表示i个结点的二叉搜索树的数量，则：
//
//		数字1作根结点的时候，左子树要小于根结点，右子树要大于根结点。因此左子树有0个结点，右子树有n-1个结点 -> 共有G(0)*G(n-1)种可能。
//		数字2作根结点，左子树1个结点，右子树n-2个结点 -> 共有G(1)*G(n-2)种可能。
//		以此类推
//		数字i作为根结点，左子树i-1个结点，右子树n-i个结点 -> 共有G(i-1)*G(n-i)种可能。
//
//		综上，G(n)应该等于从1一直到n分别作为根的树型数量的总和，列出状态转移方程：
//		  G(n)=G(0)*G(n−1)+G(1)*G(n−2)+G(2)*G(n−3)+...+G(i)*G(n−i-1)+...+G(n−1)G(0)
//	        1作为根      2作为根      3作为根          i+1作为根           n作为根
//		显然：G[0] = 1，G[1] = 1
func CalcTreeCnt(n int) int {
	g := make([]int, n+1)
	g[0] = 1
	g[1] = 1

	// 从2开始，一直到n，计算出每一个G[i]
	for i := 2; i <= n; i++ {
		cnt := 0
		for j := 0; j < i; j++ {
			cnt += g[j] * g[i-j-1]
		}
		g[i] = cnt
	}

	return g[n]
}
