/*
 * 面试题10：斐波那契数列
 * 题目：写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。
 */
package _10_fibonacci

//PS：跨台阶问题
//有一座高度是n级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。求走完这个台阶一共有多少种走法。
//F(2) = 2
//F(1) = 1
//F(n) = F(n-1) + F(n-2) (n≥3)
//分析思路：
/*
 思路1：可以这样想，需要跨越n层阶梯，那么第一步我跨1层阶梯，那么剩下n-1层阶梯，跨越这n-1阶台阶的方法
　　　　 就有F（n-1）方法； 同理，第一步跨2层阶梯，那么跨越剩下的n-2层阶梯就有F（n-2）种方法。
        所以跨越n层阶梯的方法数  F（n）= F（n-1）+ F（n-2）；
 思路2. 如果上面大家不理解，还可以这样理解，假如我们已经知道了F（n-1）和F（n-2），求F（n）；
        在F（n-2）的基础上，我们可以通过一次跨2层阶梯到达第n层，也可以通过先跨1步，再跨1步的方式到达第n层。
        我们可以这样理解，
        如果一次性跨2层阶梯，我们只是在每一种跨越n-2层阶梯方式的基础上再加上2就能到达第n层阶梯了，所以方法还是F（n-2）；
        如果先跨1步，这样加上原来的n-2步，就一共走了n-1步了，方法数就是F（n-1）了，然后再跨多1步，同上，我们只是在每一种跨越
        n-1层阶梯方式的基础上再加上1就能到达第n层阶梯了，所以方法还是F（n-1）。
*/

// 递归写法
// 递归的问题：往往可能存在大量的重复计算！！所以性能不会高！也有可能栈溢出的风险。
func FibonacciRecurse(n int) int {
	if n <= 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	if n == 2 {
		return 2
	}

	return FibonacciRecurse(n-1) + FibonacciRecurse(n-2)
}

// 非递归
// 不用递归的时候，自然联想到利用循环或者栈
func FibonacciNoRecurse(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	dp := make([]int, n+1)
	dp[0] = 0
	dp[1] = 1
	dp[2] = 2
	for i := 3; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}
